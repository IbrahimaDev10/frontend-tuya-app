import os
from tuya_iot import TuyaOpenAPI
from datetime import datetime, timedelta

class TuyaClient:
    def __init__(self):
        self.openapi = None
        self.token_info = None
        self.is_connected = False
        
    def connect(self, username, password, country_code="221", app_type="smart_life"):
        """Connexion √† Tuya avec les identifiants utilisateur"""
        try:
            # Configuration depuis les variables d'environnement
            endpoint = os.getenv('TUYA_ENDPOINT', 'https://openapi.tuyaeu.com')
            access_id = os.getenv('ACCESS_ID')
            access_key = os.getenv('ACCESS_KEY')
            
            print(f"üîß Tentative connexion Tuya:")
            print(f"   Endpoint: {endpoint}")
            print(f"   Access ID: {access_id[:10]}..." if access_id else "None")
            print(f"   Username: {username}")
            
            # Cr√©er l'instance TuyaOpenAPI
            self.openapi = TuyaOpenAPI(
                endpoint=endpoint,
                access_id=access_id,
                access_secret=access_key  # ‚úÖ CORRIG√â: access_secret au lieu de access_key
            )
            
            # ‚úÖ CORRIG√â: Logique de connexion adapt√©e aux vraies r√©ponses
            print(f"üîß Test connexion Tuya avec connect()")
            try:
                # La m√©thode connect() retourne un dict avec code, m√™me si √ßa marche
                connected_response = self.openapi.connect(username, password, country_code, "smart_life")
                print(f"üìä R√©sultat connect(): {connected_response}")
                
                # V√©rifier si c'est vraiment connect√©, m√™me si success=False
                # Code 0 ou 1000 peut indiquer succ√®s selon l'API Tuya
                is_connected = False
                
                if isinstance(connected_response, dict):
                    code = connected_response.get('code', -1)
                    success = connected_response.get('success', False)
                    
                    # Code 0 = succ√®s dans certains cas Tuya
                    if code == 0 or success:
                        is_connected = True
                elif connected_response is True:
                    is_connected = True
                
                # Test de l'API pour v√©rifier la vraie connexion
                if not is_connected:
                    try:
                        # Tester avec un endpoint simple
                        test_response = self.openapi.get('/v2.0/cloud/thing/device?page_size=1')
                        if test_response.get('success') or 'result' in test_response:
                            is_connected = True
                            print("üìä Connexion confirm√©e par test API")
                    except:
                        pass
                
                if is_connected:
                    # R√©cup√©ration manuelle du token si n√©cessaire
                    self.token_info = getattr(self.openapi, 'token_info', None)
                    
                    # Si pas de token_info, essayer de le r√©cup√©rer
                    if not self.token_info:
                        try:
                            token_response = self.openapi.get('/v1.0/token')
                            if token_response.get('success'):
                                self.token_info = token_response.get('result')
                        except:
                            pass
                    
                    self.is_connected = True
                    print(f"‚úÖ Connexion Tuya r√©ussie pour {username}")
                    print(f"üé´ Token info: {self.token_info}")
                    return True
                else:
                    # Tenter avec d'autres schemas
                    schemas_to_try = ['tuya', 'smartlife', 'Smart Life']
                    for schema in schemas_to_try:
                        print(f"üîß Test connexion avec schema: {schema}")
                        try:
                            alt_response = self.openapi.connect(username, password, country_code, schema)
                            print(f"üìä R√©sultat connect {schema}: {alt_response}")
                            
                            # M√™me logique de v√©rification
                            alt_connected = False
                            if isinstance(alt_response, dict):
                                code = alt_response.get('code', -1)
                                success = alt_response.get('success', False)
                                if code == 0 or success:
                                    alt_connected = True
                            elif alt_response is True:
                                alt_connected = True
                            
                            if alt_connected:
                                self.token_info = getattr(self.openapi, 'token_info', None)
                                self.is_connected = True
                                print(f"‚úÖ Connexion Tuya r√©ussie avec {schema} pour {username}")
                                print(f"üé´ Token info: {self.token_info}")
                                return True
                                
                        except Exception as e:
                            print(f"‚ùå Erreur schema {schema}: {e}")
                            continue
                    
                    # Si aucun schema ne marche
                    self.is_connected = False
                    print(f"‚ùå Connexion Tuya √©chou√©e pour {username} avec tous les schemas")
                    return False
                    
            except Exception as e:
                print(f"‚ùå Erreur connect principal: {e}")
                self.is_connected = False
                return False
                
        except Exception as e:
            print(f"‚ùå Erreur connexion Tuya: {e}")
            import traceback
            print(f"üìã Traceback: {traceback.format_exc()}")
            self.is_connected = False
            return False
    
    def auto_connect_from_env(self):
        """Connexion automatique depuis les variables d'environnement"""
        try:
            # ‚úÖ CORRIG√â: Priorit√© √† TUYA_USERNAME
            username = os.getenv('TUYA_USERNAME')
            if not username:
                username = os.getenv('USERNAME')
                # Si c'est "simplon", forcer le bon username
                if username == "simplon":
                    username = "ibrahman1970@gmail.com"
                    print("üîß Username 'simplon' corrig√© vers ibrahman1970@gmail.com")
            
            password = os.getenv('PASSWORD')
            country_code = os.getenv('COUNTRY_CODE', '221')
            
            print(f"üîç Variables r√©cup√©r√©es:")
            print(f"   TUYA_USERNAME: {os.getenv('TUYA_USERNAME')}")
            print(f"   USERNAME: {os.getenv('USERNAME')}")
            print(f"   Username final: {username}")
            print(f"   Password: {'***' if password else 'None'}")
            print(f"   Country: {country_code}")
            
            if not username or not password:
                print("‚ùå USERNAME ou PASSWORD manquants dans .env")
                return False
            
            return self.connect(username, password, country_code)
            
        except Exception as e:
            print(f"‚ùå Erreur connexion auto depuis .env: {e}")
            import traceback
            print(f"üìã Traceback: {traceback.format_exc()}")
            return False
    
    def check_connection(self):
        """V√©rifier si la connexion est toujours active"""
        if not self.is_connected or not self.openapi:
            return False
        
        try:
            # ‚úÖ CORRIG√â: Test plus simple avec les homes
            response = self.get_user_homes()
            success = response.get("success", False)
            has_result = "result" in response and len(response.get("result", [])) > 0
            
            print(f"üîç Test connexion - Success: {success}, Has result: {has_result}")
            return success and has_result
        except Exception as e:
            print(f"‚ùå Erreur test connexion: {e}")
            self.is_connected = False
            return False
    
    def reconnect_if_needed(self):
        """Reconnexion automatique si n√©cessaire"""
        if not self.check_connection():
            print("üîÑ Reconnexion Tuya n√©cessaire...")
            return self.auto_connect_from_env()
        return True
    
    def get_token_info(self):
        """R√©cup√©rer les informations du token"""
        return self.token_info
    
    def get_connection_info(self):
        """R√©cup√©rer les informations de connexion actuelle"""
        # ‚úÖ CORRIG√â: Utiliser TUYA_USERNAME en priorit√©
        username = os.getenv('TUYA_USERNAME') or os.getenv('USERNAME', '')
        if username == "simplon":
            username = "ibrahman1970@gmail.com (corrig√©)"
            
        return {
            "is_connected": self.is_connected,
            "endpoint": os.getenv('TUYA_ENDPOINT', 'https://openapi.tuyaeu.com'),
            "access_id": os.getenv('ACCESS_ID', '')[:10] + "..." if os.getenv('ACCESS_ID') else None,
            "username": username,
            "token_info": self.token_info,
            "last_check": datetime.utcnow().isoformat()
        }
    
    # =================== M√âTHODES API CORRIG√âES ===================
    
    def get_user_homes(self):
        """R√©cup√©rer les homes/espaces de l'utilisateur"""
        if not self.is_connected or not self.openapi:
            raise Exception("Client Tuya non connect√©")
        
        try:
            if not self.token_info or not self.token_info.get('uid'):
                print("‚ùå Token info manquant ou UID non trouv√©")
                return {"success": False, "result": []}
                
            uid = self.token_info.get('uid')
            print(f"üîç R√©cup√©ration homes pour UID: {uid}")
            response = self.openapi.get(f"/v1.0/users/{uid}/homes")
            print(f"üìä R√©ponse homes: {response}")
            return response
        except Exception as e:
            print(f"‚ùå Erreur r√©cup√©ration homes: {e}")
            return {"success": False, "result": []}
    
    def get_devices(self):
        """R√©cup√©rer la liste des appareils"""
        if not self.reconnect_if_needed():
            raise Exception("Impossible de se connecter √† Tuya")
        
        try:
            # ‚úÖ CORRIG√â: Utiliser la m√©thode homes -> devices
            homes_response = self.get_user_homes()
            if not homes_response.get("success") or not homes_response.get("result"):
                print("‚ùå Aucun home trouv√©")
                return {"success": False, "result": []}
            
            all_devices = []
            homes = homes_response.get("result", [])
            
            for home in homes:
                home_id = home.get("home_id")
                home_name = home.get("name", "Home")
                print(f"üè† R√©cup√©ration appareils pour home: {home_name} ({home_id})")
                
                try:
                    response = self.openapi.get(f"/v1.0/homes/{home_id}/devices")
                    print(f"üìä R√©ponse appareils home {home_id}: {response}")
                    
                    if response.get("success") and response.get("result"):
                        devices = response.get("result", [])
                        # Ajouter l'info du home √† chaque appareil
                        for device in devices:
                            device["home_id"] = home_id
                            device["home_name"] = home_name
                        all_devices.extend(devices)
                        print(f"‚úÖ {len(devices)} appareils trouv√©s dans {home_name}")
                    else:
                        print(f"‚ö†Ô∏è Aucun appareil dans home {home_name}")
                        
                except Exception as e:
                    print(f"‚ùå Erreur appareils home {home_id}: {e}")
                    continue
            
            print(f"üìä Total: {len(all_devices)} appareils trouv√©s")
            return {"success": True, "result": all_devices}
            
        except Exception as e:
            print(f"‚ùå Erreur r√©cup√©ration appareils: {e}")
            import traceback
            print(f"üìã Traceback: {traceback.format_exc()}")
            return {"success": False, "result": []}
    
    def get_device_status(self, device_id):
        """R√©cup√©rer le statut d'un appareil"""
        if not self.reconnect_if_needed():
            raise Exception("Impossible de se connecter √† Tuya")
        
        try:
            print(f"üîç R√©cup√©ration statut appareil {device_id}...")
            # ‚úÖ CORRIG√â: Utiliser l'endpoint correct
            response = self.openapi.get(f"/v1.0/iot-03/devices/{device_id}/status")
            print(f"üìä R√©ponse statut: {response}")
            return response
        except Exception as e:
            print(f"‚ùå Erreur statut appareil {device_id}: {e}")
            return {"success": False, "result": []}
    
    def send_device_command(self, device_id, commands):
        """Envoyer une commande √† un appareil"""
        if not self.reconnect_if_needed():
            raise Exception("Impossible de se connecter √† Tuya")
        
        try:
            print(f"üîß Envoi commande √† {device_id}: {commands}")
            response = self.openapi.post(f"/v1.0/iot-03/devices/{device_id}/commands", commands)
            print(f"üìä R√©ponse commande: {response}")
            return response
        except Exception as e:
            print(f"‚ùå Erreur commande appareil {device_id}: {e}")
            return {"success": False, "error": str(e)}
    
    def get_spaces(self):
        """R√©cup√©rer les espaces (alias pour get_user_homes)"""
        return self.get_user_homes()
    
    def get_device_logs(self, device_id, code, start_time, end_time):
        """R√©cup√©rer les logs d'un appareil"""
        if not self.reconnect_if_needed():
            raise Exception("Impossible de se connecter √† Tuya")
        
        try:
            url = f"/v1.0/iot-03/devices/{device_id}/logs"
            params = {
                "codes": code,
                "end_time": end_time,
                "size": 100,
                "start_time": start_time
            }
            print(f"üîç R√©cup√©ration logs {device_id} pour {code}...")
            response = self.openapi.get(url, params)
            print(f"üìä R√©ponse logs: {response}")
            return response
        except Exception as e:
            print(f"‚ùå Erreur logs appareil {device_id}: {e}")
            return {"success": False, "result": []}
    
    # =================== M√âTHODES UTILES ===================
    
    def get_device_details(self, device_id):
        """R√©cup√©rer les d√©tails complets d'un appareil"""
        if not self.reconnect_if_needed():
            raise Exception("Impossible de se connecter √† Tuya")
        
        try:
            print(f"üîç R√©cup√©ration d√©tails appareil {device_id}...")
            response = self.openapi.get(f"/v1.0/iot-03/devices/{device_id}")
            print(f"üìä R√©ponse d√©tails: {response}")
            return response
        except Exception as e:
            print(f"‚ùå Erreur d√©tails appareil {device_id}: {e}")
            return {"success": False, "result": []}
    
    def get_all_devices_with_details(self):
        """R√©cup√©rer tous les appareils avec d√©tails complets"""
        try:
            print("üîç R√©cup√©ration tous appareils avec d√©tails...")
            devices_response = self.get_devices()
            
            if not devices_response.get("success"):
                return {"success": False, "result": [], "error": "Impossible de r√©cup√©rer les appareils"}
            
            devices = devices_response.get("result", [])
            print(f"üìä {len(devices)} appareils trouv√©s")
            
            detailed_devices = []
            for device in devices:
                device_id = device.get("id") or device.get("device_id", "")
                if device_id:
                    # R√©cup√©rer les d√©tails pour chaque appareil
                    details_response = self.get_device_details(device_id)
                    if details_response.get("success") and details_response.get("result"):
                        # Fusionner les informations
                        device_info = details_response.get("result")
                        device_info.update(device)  # Ajouter les infos de base
                        detailed_devices.append(device_info)
                    else:
                        detailed_devices.append(device)
                else:
                    print(f"‚ö†Ô∏è Appareil sans device_id trouv√©: {device}")
                    detailed_devices.append(device)
            
            print(f"‚úÖ {len(detailed_devices)} appareils avec d√©tails")
            return {"success": True, "result": detailed_devices}
            
        except Exception as e:
            print(f"‚ùå Erreur r√©cup√©ration appareils d√©taill√©s: {e}")
            import traceback
            print(f"üìã Traceback: {traceback.format_exc()}")
            return {"success": False, "result": [], "error": str(e)}
    
    def get_device_current_values(self, device_id):
        """R√©cup√©rer les valeurs actuelles d'un appareil (tension, courant, etc.)"""
        try:
            print(f"üîç R√©cup√©ration valeurs actuelles {device_id}...")
            status_response = self.get_device_status(device_id)
            
            if not status_response.get("success"):
                return {"success": False, "message": "Erreur r√©cup√©ration statut"}
            
            status_data = status_response.get("result", [])
            print(f"üìä Status data brut: {status_data}")
            
            # Mapper les codes Tuya vers des noms plus clairs
            values = {}
            for item in status_data:
                code = item.get("code", "")
                value = item.get("value")
                
                # Mapping pour les compteurs ATORCH
                if code == "cur_voltage":
                    values["tension"] = value / 10 if value else None  # Diviser par 10 pour avoir les volts
                elif code == "cur_current":
                    values["courant"] = value / 1000 if value else None  # Diviser par 1000 pour avoir les amp√®res
                elif code == "cur_power":
                    values["puissance"] = value / 10 if value else None  # Diviser par 10 pour avoir les watts
                elif code == "add_ele":
                    values["energie"] = value / 1000 if value else None  # Diviser par 1000 pour avoir les kWh
                elif code == "switch":
                    values["etat_switch"] = bool(value)
                else:
                    values[code] = value
            
            print(f"‚úÖ Valeurs mapp√©es: {values}")
            
            return {
                "success": True,
                "device_id": device_id,
                "timestamp": datetime.utcnow().isoformat(),
                "values": values,
                "raw_status": status_data
            }
            
        except Exception as e:
            print(f"‚ùå Erreur valeurs actuelles {device_id}: {e}")
            import traceback
            print(f"üìã Traceback: {traceback.format_exc()}")
            return {"success": False, "error": str(e)}
    
    def toggle_device(self, device_id, state=None):
        """Allumer/√©teindre un appareil (toggle ou √©tat sp√©cifique)"""
        try:
            print(f"üîß Toggle appareil {device_id} - state: {state}")
            
            if state is None:
                # Mode toggle : r√©cup√©rer l'√©tat actuel d'abord
                current_status = self.get_device_current_values(device_id)
                if current_status.get("success"):
                    current_state = current_status.get("values", {}).get("etat_switch", False)
                    new_state = not current_state
                    print(f"üîÑ Toggle: {current_state} -> {new_state}")
                else:
                    new_state = True  # Par d√©faut allumer si on ne peut pas r√©cup√©rer l'√©tat
                    print("üîÑ √âtat inconnu, allumer par d√©faut")
            else:
                new_state = bool(state)
                print(f"üîß √âtat forc√©: {new_state}")
            
            commands = {
                "commands": [
                    {
                        "code": "switch",
                        "value": new_state
                    }
                ]
            }
            
            response = self.send_device_command(device_id, commands)
            
            return {
                "success": response.get("success", False),
                "new_state": new_state,
                "action": "allum√©" if new_state else "√©teint",
                "response": response
            }
            
        except Exception as e:
            print(f"‚ùå Erreur toggle appareil {device_id}: {e}")
            import traceback
            print(f"üìã Traceback: {traceback.format_exc()}")
            return {"success": False, "error": str(e)}
    
    def get_device_logs_formatted(self, device_id, code, hours_back=24):
        """R√©cup√©rer les logs avec formatage automatique des dates"""
        try:
            print(f"üîç R√©cup√©ration logs format√©s {device_id} - {code} - {hours_back}h")
            
            # Calculer les timestamps
            end_time = int(datetime.utcnow().timestamp() * 1000)
            start_time = int((datetime.utcnow() - timedelta(hours=hours_back)).timestamp() * 1000)
            
            logs_response = self.get_device_logs(device_id, code, start_time, end_time)
            logs = logs_response.get("result", [])
            
            # Formatter les donn√©es
            formatted_logs = []
            for log in logs:
                formatted_log = {
                    "timestamp": datetime.fromtimestamp(log.get("event_time", 0) / 1000).isoformat(),
                    "code": log.get("code"),
                    "value": log.get("value"),
                    "event_time": log.get("event_time")
                }
                formatted_logs.append(formatted_log)
            
            print(f"‚úÖ {len(formatted_logs)} logs format√©s")
            
            return {
                "success": True,
                "device_id": device_id,
                "code": code,
                "period_hours": hours_back,
                "count": len(formatted_logs),
                "data": formatted_logs
            }
            
        except Exception as e:
            print(f"‚ùå Erreur logs format√©s {device_id}: {e}")
            import traceback
            print(f"üìã Traceback: {traceback.format_exc()}")
            return {"success": False, "error": str(e)}
    
    def get_multiple_device_status(self, device_ids):
        """R√©cup√©rer le statut de plusieurs appareils en une fois"""
        try:
            if isinstance(device_ids, list):
                device_ids_str = ",".join(device_ids)
            else:
                device_ids_str = str(device_ids)
            
            print(f"üîç R√©cup√©ration statut multiple: {device_ids_str}")
            response = self.openapi.get(f"/v1.0/iot-03/devices/status?device_ids={device_ids_str}")
            print(f"üìä R√©ponse statut multiple: {response}")
            return response
            
        except Exception as e:
            print(f"‚ùå Erreur statut multiple appareils: {e}")
            return {"success": False, "result": []}
    
    def search_devices_by_name(self, search_term):
        """Rechercher des appareils par nom"""
        try:
            print(f"üîç Recherche appareils par nom: {search_term}")
            all_devices = self.get_all_devices_with_details()
            if not all_devices.get("success"):
                return {"success": False, "result": []}
            
            devices = all_devices.get("result", [])
            search_term_lower = search_term.lower()
            
            filtered_devices = []
            for device in devices:
                device_name = device.get("name", "").lower()
                if search_term_lower in device_name:
                    filtered_devices.append(device)
            
            print(f"‚úÖ {len(filtered_devices)} appareils trouv√©s")
            
            return {
                "success": True,
                "search_term": search_term,
                "count": len(filtered_devices),
                "result": filtered_devices
            }
            
        except Exception as e:
            print(f"‚ùå Erreur recherche appareils: {e}")
            import traceback
            print(f"üìã Traceback: {traceback.format_exc()}")
            return {"success": False, "error": str(e)}