from flask_jwt_extended import create_access_token, create_refresh_token
from app import db
from app.models import User, Client
from app.services.mail_service import MailService  # ‚úÖ NOUVEAU : Import du service mail
from datetime import datetime, timedelta
import secrets
import re
import logging

class AuthService:
    def __init__(self):
        # Stockage temporaire des tokens de reset (en production, utiliser Redis)
        self.reset_tokens = {}
    
    def register(self, user_data, created_by_user=None):
        """
        Enregistrer un nouvel utilisateur
        - Si created_by_user est None : cr√©ation du premier superadmin
        - Si created_by_user existe : cr√©ation selon les permissions
        """
        try:
            # Validation des donn√©es
            if not self._validate_user_data(user_data):
                return None, "Donn√©es utilisateur invalides"
            
            # V√©rifier si l'email existe d√©j√†
            existing_user = User.query.filter_by(email=user_data['email'].lower().strip()).first()
            if existing_user:
                return None, "Un utilisateur avec cet email existe d√©j√†"
            
            # D√©terminer le r√¥le et client_id
            role = user_data.get('role', 'user')
            client_id = user_data.get('client_id')
            
            # Gestion des permissions
            if created_by_user is None:
                # Premier superadmin (installation)
                role = 'superadmin'
                client_id = None
            elif created_by_user.is_superadmin():
                # Superadmin peut cr√©er n'importe quel utilisateur
                if role == 'superadmin':
                    client_id = None
                elif not client_id and role != 'superadmin':
                    return None, "client_id requis pour les utilisateurs non-superadmin"
            elif created_by_user.is_admin():
                # Admin peut cr√©er seulement des users de son client
                if role in ['superadmin', 'admin']:
                    return None, "Permission insuffisante pour cr√©er ce type d'utilisateur"
                client_id = created_by_user.client_id
            else:
                return None, "Permission insuffisante"
            
            # ‚úÖ Cr√©er l'utilisateur selon TON mod√®le exact
            user = User(
                prenom=user_data['prenom'].strip(),
                nom=user_data['nom'].strip(),
                email=user_data['email'].lower().strip(),
                telephone=user_data.get('telephone', '').strip() or None,
                role=role,
                client_id=client_id
            )
            
            # D√©finir le mot de passe avec TA m√©thode
            password = user_data.get('password')
            if not password:
                password = self._generate_temp_password()
            
            user.set_password(password)  # Utilise ta m√©thode qui g√®re mot_de_passe_hash
            
            db.session.add(user)
            db.session.commit()
            
            # ‚úÖ NOUVEAU : Envoyer email de bienvenue
            if MailService.is_enabled():
                welcome_result = MailService.send_welcome_email(user.email, user.nom_complet)
                if welcome_result['success']:
                    logging.info(f"Email de bienvenue envoy√© √† {user.email}")
                else:
                    logging.warning(f"√âchec envoi email bienvenue: {welcome_result['message']}")
            
            return user, None
            
        except Exception as e:
            db.session.rollback()
            return None, f"Erreur lors de l'enregistrement: {str(e)}"
    
    def login(self, email, password):
        """Connexion utilisateur avec dur√©es optimis√©es"""
        try:
            # Validation des entr√©es
            if not email or not password:
                return None, "Email et mot de passe requis"
            
            email = email.lower().strip()
            
            # Rechercher l'utilisateur avec TES champs
            user = User.query.filter_by(email=email, actif=True).first()
            if not user:
                return None, "Email ou mot de passe incorrect"
            
            # V√©rifier le mot de passe avec TA m√©thode
            if not user.check_password(password):
                return None, "Email ou mot de passe incorrect"
            
            # Mettre √† jour la derni√®re connexion avec TA m√©thode
            user.update_last_login()
            
            # üïê DUR√âES OPTIMIS√âES : Access 1h, Refresh 8h
            access_token = create_access_token(
                identity=user.id,
                additional_claims={
                    'role': user.role,
                    'client_id': user.client_id,
                    'email': user.email,
                    'nom_complet': user.nom_complet  # TA propri√©t√©
                },
                expires_delta=timedelta(hours=1)  # ‚úÖ 1 heure au lieu de 24h
            )
            
            refresh_token = create_refresh_token(
                identity=user.id,
                expires_delta=timedelta(hours=8)  # ‚úÖ 8 heures au lieu de 30 jours
            )
            
            return {
                'access_token': access_token,
                'refresh_token': refresh_token,
                'user': user.to_dict(),  # TA m√©thode to_dict
                'expires_in': 1 * 3600,        # ‚úÖ 3600 secondes = 1 heure
                'refresh_expires_in': 8 * 3600  # ‚úÖ 28800 secondes = 8 heures
            }, None
            
        except Exception as e:
            return None, f"Erreur lors de la connexion: {str(e)}"
    
    def refresh_token(self, user_id):
        """Renouveler le token d'acc√®s"""
        try:
            user = User.query.get(user_id)
            if not user or not user.actif:
                return None, "Utilisateur non trouv√© ou inactif"
            
            # Cr√©er un nouveau access token
            new_access_token = create_access_token(
                identity=user.id,
                additional_claims={
                    'role': user.role,
                    'client_id': user.client_id,
                    'email': user.email,
                    'nom_complet': user.nom_complet
                },
                expires_delta=timedelta(hours=1)  # 1 heure
            )
            
            return {
                'access_token': new_access_token,
                'expires_in': 3600,  # 1 heure en secondes
                'user': user.to_dict()
            }, None
            
        except Exception as e:
            return None, f"Erreur lors du renouvellement: {str(e)}"
    
    def logout(self, user_id):
        """D√©connexion (c√¥t√© serveur)"""
        try:
            # En production, ajouter le token √† une blacklist
            user = User.query.get(user_id)
            if user:
                # Log optionnel de d√©connexion
                pass
            
            return True, "D√©connexion r√©ussie"
            
        except Exception as e:
            return False, f"Erreur lors de la d√©connexion: {str(e)}"
    
    def get_profile(self, user_id):
        """R√©cup√©rer le profil utilisateur"""
        try:
            user = User.query.get(user_id)
            if not user or not user.actif:
                return None, "Utilisateur non trouv√©"
            
            # Utiliser TA m√©thode to_dict avec include_sensitive
            profile_data = user.to_dict(include_sensitive=True)
            
            # Ajouter des informations sur les permissions avec TES m√©thodes
            profile_data['permissions'] = {
                'is_superadmin': user.is_superadmin(),
                'is_admin': user.is_admin(),
                'can_manage_users': user.is_admin(),
                'can_manage_devices': user.is_admin()
            }
            
            return profile_data, None
            
        except Exception as e:
            return None, f"Erreur lors de la r√©cup√©ration: {str(e)}"
    
    def update_profile(self, user_id, profile_data):
        """Mettre √† jour le profil"""
        try:
            user = User.query.get(user_id)
            if not user:
                return None, "Utilisateur non trouv√©"
            
            # Champs modifiables par l'utilisateur selon TON mod√®le
            allowed_fields = ['prenom', 'nom', 'telephone']
            
            for field in allowed_fields:
                if field in profile_data and profile_data[field] is not None:
                    value = str(profile_data[field]).strip()
                    if field in ['prenom', 'nom'] and not value:
                        return None, f"Le champ {field} ne peut pas √™tre vide"
                    setattr(user, field, value if value else None)
            
            db.session.commit()
            
            return user.to_dict(), None  # TA m√©thode to_dict
            
        except Exception as e:
            db.session.rollback()
            return None, f"Erreur lors de la mise √† jour: {str(e)}"
    
    def change_password(self, user_id, old_password, new_password):
        """Changer le mot de passe"""
        try:
            user = User.query.get(user_id)
            if not user:
                return False, "Utilisateur non trouv√©"
            
            # V√©rifier l'ancien mot de passe avec TA m√©thode
            if not user.check_password(old_password):
                return False, "Ancien mot de passe incorrect"
            
            # Valider le nouveau mot de passe
            if not self._validate_password(new_password):
                return False, "Le nouveau mot de passe doit contenir au moins 8 caract√®res"
            
            # Changer le mot de passe avec TA m√©thode
            user.set_password(new_password)
            db.session.commit()
            
            # ‚úÖ NOUVEAU : Envoyer notification de changement
            if MailService.is_enabled():
                notification_result = MailService.send_password_changed_notification(
                    user.email, 
                    user.nom_complet
                )
                if notification_result['success']:
                    logging.info(f"Notification changement mot de passe envoy√©e √† {user.email}")
            
            return True, "Mot de passe modifi√© avec succ√®s"
            
        except Exception as e:
            db.session.rollback()
            return False, f"Erreur lors du changement: {str(e)}"
    
    def forgot_password(self, email):
        """
        Demander la r√©initialisation du mot de passe avec envoi d'email
        ‚úÖ AM√âLIOR√â : Avec envoi d'email et dur√©e de 5 minutes
        """
        try:
            email = email.lower().strip()
            user = User.query.filter_by(email=email, actif=True).first()
            
            # Pour la s√©curit√©, on retourne toujours success m√™me si l'email n'existe pas
            if not user:
                return True, "Si cet email existe, vous recevrez un lien de r√©initialisation"
            
            # G√©n√©rer un token de r√©initialisation
            reset_token = secrets.token_urlsafe(32)
            
            # ‚úÖ MODIFI√â : Expiration √† 5 minutes au lieu d'1 heure
            expires_at = datetime.utcnow() + timedelta(minutes=5)
            
            # Stocker le token avec expiration (5 minutes)
            self.reset_tokens[reset_token] = {
                'user_id': user.id,
                'email': user.email,
                'expires_at': expires_at
            }
            
            # ‚úÖ NOUVEAU : Envoyer l'email de r√©initialisation
            if MailService.is_enabled():
                email_result = MailService.send_password_reset_email(
                    user_email=user.email,
                    username=user.nom_complet,
                    reset_token=reset_token,
                    expires_minutes=5
                )
                
                if email_result['success']:
                    logging.info(f"Email de r√©initialisation envoy√© √† {user.email}")
                    return True, "Un email de r√©initialisation a √©t√© envoy√©. Le lien expire dans 5 minutes."
                else:
                    # Si l'email n'a pas pu √™tre envoy√©, supprimer le token
                    if reset_token in self.reset_tokens:
                        del self.reset_tokens[reset_token]
                    logging.error(f"√âchec envoi email r√©initialisation: {email_result['message']}")
                    return False, "Erreur lors de l'envoi de l'email. Veuillez r√©essayer."
            else:
                # Service mail non configur√© - mode d√©veloppement
                logging.warning("Service mail non configur√© - token retourn√© pour d√©veloppement")
                return True, f"Token de r√©initialisation (dev): {reset_token}"
            
        except Exception as e:
            # Nettoyer le token en cas d'erreur
            if 'reset_token' in locals() and reset_token in self.reset_tokens:
                del self.reset_tokens[reset_token]
            return False, f"Erreur lors de la demande: {str(e)}"
    
    def reset_password(self, token, new_password):
        """
        R√©initialiser le mot de passe avec un token
        ‚úÖ AM√âLIOR√â : Avec notification par email
        """
        try:
            # V√©rifier le token
            if token not in self.reset_tokens:
                return False, "Token invalide ou expir√©"
            
            token_data = self.reset_tokens[token]
            
            # V√©rifier l'expiration (5 minutes)
            if datetime.utcnow() > token_data['expires_at']:
                del self.reset_tokens[token]
                return False, "Token expir√©. Veuillez refaire une demande de r√©initialisation."
            
            # Valider le nouveau mot de passe
            if not self._validate_password(new_password):
                return False, "Le mot de passe doit contenir au moins 8 caract√®res"
            
            # Trouver l'utilisateur
            user = User.query.get(token_data['user_id'])
            if not user or not user.actif:
                del self.reset_tokens[token]
                return False, "Utilisateur non trouv√©"
            
            # Changer le mot de passe avec TA m√©thode
            user.set_password(new_password)
            db.session.commit()
            
            # ‚úÖ NOUVEAU : Envoyer notification de changement r√©ussi
            if MailService.is_enabled():
                notification_result = MailService.send_password_changed_notification(
                    user.email, 
                    user.nom_complet
                )
                if notification_result['success']:
                    logging.info(f"Notification changement mot de passe envoy√©e √† {user.email}")
            
            # Supprimer le token utilis√©
            del self.reset_tokens[token]
            
            return True, "Mot de passe r√©initialis√© avec succ√®s"
            
        except Exception as e:
            db.session.rollback()
            return False, f"Erreur lors de la r√©initialisation: {str(e)}"
    
    def admin_reset_password(self, target_email, new_password, admin_user):
        """R√©initialisation par un administrateur"""
        try:
            if not admin_user.is_admin():  # TA m√©thode
                return False, "Permission insuffisante"
            
            target_user = User.query.filter_by(email=target_email.lower().strip()).first()
            if not target_user:
                return False, "Utilisateur non trouv√©"
            
            # V√©rifier que l'admin peut g√©rer cet utilisateur avec TES m√©thodes
            if not admin_user.is_superadmin():
                if target_user.client_id != admin_user.client_id:
                    return False, "Vous ne pouvez g√©rer que les utilisateurs de votre organisation"
                
                if target_user.role in ['superadmin', 'admin']:
                    return False, "Permission insuffisante pour ce type d'utilisateur"
            
            # Valider le mot de passe
            if not self._validate_password(new_password):
                return False, "Le mot de passe doit contenir au moins 8 caract√®res"
            
            # R√©initialiser avec TA m√©thode
            target_user.set_password(new_password)
            db.session.commit()
            
            # ‚úÖ NOUVEAU : Envoyer notification √† l'utilisateur
            if MailService.is_enabled():
                notification_result = MailService.send_password_changed_notification(
                    target_user.email, 
                    target_user.nom_complet
                )
                if notification_result['success']:
                    logging.info(f"Notification r√©initialisation admin envoy√©e √† {target_user.email}")
            
            return True, f"Mot de passe r√©initialis√© pour {target_user.nom_complet}"  # TA propri√©t√©
            
        except Exception as e:
            db.session.rollback()
            return False, f"Erreur lors de la r√©initialisation: {str(e)}"
    
    def get_reset_token_info(self, token):
        """
        ‚úÖ NOUVEAU : V√©rifier les informations d'un token de r√©initialisation
        Utile pour valider le token c√¥t√© frontend avant la soumission
        """
        if token not in self.reset_tokens:
            return None, "Token invalide"
        
        token_data = self.reset_tokens[token]
        
        if datetime.utcnow() > token_data['expires_at']:
            del self.reset_tokens[token]
            return None, "Token expir√©"
        
        # Calculer le temps restant
        time_remaining = token_data['expires_at'] - datetime.utcnow()
        seconds_remaining = int(time_remaining.total_seconds())
        
        return {
            'valid': True,
            'email': token_data['email'],
            'seconds_remaining': seconds_remaining,
            'expires_at': token_data['expires_at'].isoformat()
        }, None
    
    def cleanup_expired_tokens(self):
        """
        ‚úÖ NOUVEAU : Nettoyer les tokens expir√©s
        √Ä appeler p√©riodiquement (ex: avec un cron job)
        """
        current_time = datetime.utcnow()
        expired_tokens = []
        
        for token, data in self.reset_tokens.items():
            if current_time > data['expires_at']:
                expired_tokens.append(token)
        
        for token in expired_tokens:
            del self.reset_tokens[token]
        
        if expired_tokens:
            logging.info(f"Nettoy√© {len(expired_tokens)} tokens expir√©s")
        
        return len(expired_tokens)
    
    def _validate_user_data(self, data):
        """Valider les donn√©es utilisateur selon TON mod√®le"""
        required_fields = ['prenom', 'nom', 'email']
        
        for field in required_fields:
            if not data.get(field) or not str(data[field]).strip():
                return False
        
        # Valider l'email
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(email_pattern, data['email']):
            return False
        
        return True
    
    def _validate_password(self, password):
        """Valider le mot de passe"""
        return password and len(password) >= 8
    
    def _generate_temp_password(self, length=12):
        """G√©n√©rer un mot de passe temporaire"""
        import string
        characters = string.ascii_letters + string.digits + "!@#$%"
        return ''.join(secrets.choice(characters) for _ in range(length))